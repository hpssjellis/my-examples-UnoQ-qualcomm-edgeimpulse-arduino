<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Webcam and Recorder with Trimming</title>
</head>
<body style="font-family: sans-serif; text-align: center; margin-top: 20px;">
    
    <h1 style="color: #007bff;">Webcam Capture and Recorder</h1>

        <p>My main UnoQ Index <a href="https://hpssjellis.github.io/my-examples-UnoQ-qualcomm-edgeimpulse-arduino/public/index.html"> here </a> </p>  
        <p>My UnoQ Github is<a href="https://github.com/hpssjellis/my-examples-UnoQ-qualcomm-edgeimpulse-arduino"> my-examples-of-UnoQ... </a> </p>  
        <p>You can find more of my work on my <a href="https://github.com/hpssjellis"> hpssjellis </a> GitHub Profile page:</p>
        <p>Follow me Jeremy Ellis on <a href="https://ca.linkedin.com/in/jeremy-ellis-4237a9bb"> LinkedIn </a><br></p>

    <!-- 
        1. Video Element: Used to hold the raw stream from the webcam. 
           It must be present but can be hidden or used for drawing to the canvas.
    -->
    <video id="myLiveStreamVideo" autoplay playsinline style="display: none;"></video>

    <!-- 
        2. Canvas Element: This is where the user sees the live video feed. 
           We draw the video element's content onto this for better control.
    -->
    <canvas id="myVideoCanvas" width="640" height="480" style="border: 2px solid #ccc; max-width: 90%; margin-bottom: 20px;"></canvas>

    <!-- Display area for the recorded video -->
    <video id="myRecordedVideo" controls style="display: none; border: 2px solid green; max-width: 90%; margin-bottom: 20px;"></video>

    <!-- Trimming Controls Container -->
    <div id="myTrimmingControls" style="display: none; max-width: 640px; margin: 0 auto 20px auto; padding: 15px; border: 2px solid #007bff; border-radius: 5px; background-color: #f0f8ff;">
        <h3 style="margin-top: 0;">Trim Video</h3>
        
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Start Time: <span id="myStartTimeDisplay">0.0s</span></label>
            <input type="range" id="myStartSlider" min="0" max="100" value="0" step="0.1" style="width: 100%;">
        </div>
        
        <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">End Time: <span id="myEndTimeDisplay">0.0s</span></label>
            <input type="range" id="myEndSlider" min="0" max="100" value="100" step="0.1" style="width: 100%;">
        </div>
        
        <div style="margin-bottom: 10px;">
            <strong>Duration:</strong> <span id="myDurationDisplay">0.0s</span>
        </div>
        
        <button id="mySaveTrimmedButton" style="padding: 10px 20px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-right: 10px;">
            üíæ Save Trimmed Video
        </button>
        
        <button id="myCancelTrimButton" style="padding: 10px 20px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
            ‚ùå Cancel
        </button>
    </div>

    <!-- Controls Container: Now set to display items horizontally in a single line -->
    <div id="myControls" style="display: flex; flex-direction: row; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px;">
        
        <!-- Camera Selection Dropdown -->
        <select id="myCameraSelect" style="padding: 10px; border: 1px solid #007bff; border-radius: 5px;">
            <option>Loading Cameras...</option>
        </select>
        
        <!-- Resolution Selection Dropdown -->
        <select id="myResolutionSelect" style="padding: 10px; border: 1px solid #ffc107; border-radius: 5px;">
            <option>Loading Resolutions...</option>
        </select>
        
        <!-- Format Selection Dropdown -->
        <select id="myFormatSelect" style="padding: 10px; border: 1px solid #28a745; border-radius: 5px;" disabled>
            <option>Loading Formats...</option>
        </select>
        
        <!-- Button to Take a Photo -->
        <button id="myPhotoButton" style="padding: 10px 20px; background-color: #ffc107; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;" disabled>
            üì∏ Take Photo
        </button>

        <!-- Button to Start/Stop Recording -->
        <button id="myRecordButton" style="padding: 10px 20px; background-color: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;" disabled>
            üî¥ Start Recording
        </button>
        
        <!-- Download Link for recorded video (initially hidden) -->
        <a id="myDownloadLink" style="display: none; padding: 10px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px;">Download Video</a>
    </div>

    <script>
        // --- 1. Global Variables (myVariables) ---
        const myLiveStreamVideo = document.getElementById('myLiveStreamVideo');
        const myVideoCanvas = document.getElementById('myVideoCanvas');
        const myRecordedVideo = document.getElementById('myRecordedVideo');
        const myCameraSelect = document.getElementById('myCameraSelect');
        const myResolutionSelect = document.getElementById('myResolutionSelect');
        const myFormatSelect = document.getElementById('myFormatSelect');
        const myPhotoButton = document.getElementById('myPhotoButton');
        const myRecordButton = document.getElementById('myRecordButton');
        const myDownloadLink = document.getElementById('myDownloadLink');
        const myCanvasContext = myVideoCanvas.getContext('2d');
        
        // Trimming elements
        const myTrimmingControls = document.getElementById('myTrimmingControls');
        const myStartSlider = document.getElementById('myStartSlider');
        const myEndSlider = document.getElementById('myEndSlider');
        const myStartTimeDisplay = document.getElementById('myStartTimeDisplay');
        const myEndTimeDisplay = document.getElementById('myEndTimeDisplay');
        const myDurationDisplay = document.getElementById('myDurationDisplay');
        const mySaveTrimmedButton = document.getElementById('mySaveTrimmedButton');
        const myCancelTrimButton = document.getElementById('myCancelTrimButton');
        
        let myCurrentStream = null;
        let myMediaRecorder = null;
        let myRecordedChunks = [];
        let myIsRecording = false;
        let myRecordedVideoBlob = null;
        let myVideoDuration = 0;

        // --- 2. Setup Functions ---
        
        /**
         * Loads standard video resolutions into the select box.
         */
        function myLoadResolutionPresets() {
            const myResolutionPresets = [
                { width: 1280, height: 720, name: 'HD (720p)' },
                { width: 640, height: 480, name: 'VGA (480p)' },
                { width: 320, height: 240, name: 'QVGA (240p)' },
                { width: 1920, height: 1080, name: 'Full HD (1080p)' }
            ];
            
            myResolutionSelect.innerHTML = '';
            for (const preset of myResolutionPresets) {
                const myOption = document.createElement('option');
                myOption.value = preset.width + 'x' + preset.height;
                myOption.textContent = preset.name;
                myResolutionSelect.appendChild(myOption);
            }
            myResolutionSelect.value = '640x480'; 
        }

        /**
         * Checks and loads supported video/audio recording formats into the select box.
         */
        function myLoadSupportedFormats() {
            const myFormatsToCheck = [
                { mime: 'video/webm; codecs=vp9,opus', name: 'WebM (High Quality)' },
                { mime: 'video/webm; codecs=vp8,opus', name: 'WebM (Standard)' },
                { mime: 'video/webm', name: 'WebM (Default)' },
                { mime: 'video/mp4; codecs=avc1.42001E,mp4a.40.2', name: 'MP4 (AVC/AAC - If Supported)' }, 
                { mime: 'video/mp4', name: 'MP4 (Generic - If Supported)' } 
            ];

            myFormatSelect.innerHTML = '';
            let mySupportedCount = 0;

            for (const format of myFormatsToCheck) {
                if (MediaRecorder.isTypeSupported(format.mime)) {
                    const myOption = document.createElement('option');
                    myOption.value = format.mime;
                    myOption.textContent = format.name;
                    myFormatSelect.appendChild(myOption);
                    mySupportedCount++;
                }
            }

            if (mySupportedCount > 0) {
                myFormatSelect.disabled = false;
            } else {
                myFormatSelect.innerHTML = '<option>No Recording Formats Supported</option>';
            }
        }

        /**
         * Finds all connected video input devices (webcams) and populates the select box.
         */
        async function myGetCameras() {
            myCameraSelect.innerHTML = '<option>Searching...</option>';
            try {
                await myRequestMediaPermission(); 
                
                const myDevices = await navigator.mediaDevices.enumerateDevices();
                myCameraSelect.innerHTML = '';
                let myCameraCount = 0;

                for (const myDevice of myDevices) {
                    if (myDevice.kind === 'videoinput') {
                        const myOption = document.createElement('option');
                        myOption.value = myDevice.deviceId;
                        myOption.textContent = myDevice.label || 'Camera ' + (++myCameraCount); 
                        myCameraSelect.appendChild(myOption);
                        myCameraCount++;
                    }
                }

                if (myCameraCount > 0) {
                    myChangeCamera(myCameraSelect.value);
                } else {
                    myCameraSelect.innerHTML = '<option>No Cameras Found</option>';
                }

            } catch (error) {
                console.error("Error enumerating devices:", error);
                myCameraSelect.innerHTML = '<option>Permission Denied</option>';
                alert("Please grant camera access to use this page.");
            }
        }
        
        /**
         * Requests media permission. This is necessary for enumerateDevices to get labels.
         */
        async function myRequestMediaPermission() {
            const myTempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            myTempStream.getTracks().forEach(track => track.stop());
            return myTempStream;
        }

        // --- 3. Stream Control Functions ---

        /**
         * Stops the current stream tracks (if any)
         */
        function myStopCurrentStream() {
            if (myCurrentStream) {
                myCurrentStream.getTracks().forEach(track => track.stop());
            }
        }

        /**
         * Starts a new video stream based on the selected device ID and resolution.
         */
        async function myChangeCamera(myDeviceId) {
            myStopCurrentStream();
            
            const myResolution = myResolutionSelect.value.split('x').map(Number);
            const myWidth = myResolution[0];
            const myHeight = myResolution[1];
            
            const myConstraints = {
                audio: true,
                video: {
                    deviceId: myDeviceId ? { exact: myDeviceId } : undefined,
                    width: { ideal: myWidth },
                    height: { ideal: myHeight }
                }
            };

            try {
                myCurrentStream = await navigator.mediaDevices.getUserMedia(myConstraints);
                myLiveStreamVideo.srcObject = myCurrentStream;
                myLiveStreamVideo.muted = true;
                
                console.log('Audio tracks captured: ' + myCurrentStream.getAudioTracks().length); 
                
                myLiveStreamVideo.onloadedmetadata = function() {
                    myLiveStreamVideo.play();
                    myVideoCanvas.width = myLiveStreamVideo.videoWidth;
                    myVideoCanvas.height = myLiveStreamVideo.videoHeight;
                    myDrawLoop(); 
                    
                    myPhotoButton.disabled = false;
                    myRecordButton.disabled = false;
                };

            } catch (error) {
                console.error("Error switching camera or resolution:", error);
                alert("Could not start camera with ID: " + myDeviceId + ". Try a lower resolution.");
                myPhotoButton.disabled = true;
                myRecordButton.disabled = true;
            }
        }

        // --- 4. Canvas Drawing Loop ---

        /**
         * Continuously draws the video frame onto the canvas.
         */
        function myDrawLoop() {
            if (myLiveStreamVideo.paused || myLiveStreamVideo.ended) return;

            myCanvasContext.drawImage(myLiveStreamVideo, 0, 0, myVideoCanvas.width, myVideoCanvas.height);
            
            requestAnimationFrame(myDrawLoop);
        }


        // --- 5. Photo Capture Function ---

        /**
         * Captures the current canvas content and downloads it as an image.
         */
        function myTakePhoto() {
            const myImageDataUrl = myVideoCanvas.toDataURL('image/png');
            
            const myLink = document.createElement('a');
            myLink.href = myImageDataUrl;
            myLink.download = 'webcam_photo_' + Date.now() + '.png';
            
            document.body.appendChild(myLink);
            myLink.click();
            document.body.removeChild(myLink);

            myVideoCanvas.style.border = '4px solid #ffc107';
            setTimeout(function() { myVideoCanvas.style.border = '2px solid #ccc'; }, 200);
        }

        // --- 6. Video Recording Functions ---

        /**
         * Starts or stops the video recording process.
         */
        function myToggleRecording() {
            if (myIsRecording) {
                myStopRecording();
            } else {
                myStartRecording();
            }
        }

        /**
         * Starts the video recording process using the MediaRecorder API.
         */
        function myStartRecording() {
            if (!myCurrentStream) {
                alert("Please start the camera first.");
                return;
            }

            const myMimeType = myFormatSelect.value;
            
            myMediaRecorder = new MediaRecorder(myCurrentStream, { mimeType: myMimeType });
            myRecordedChunks = [];

            myMediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    myRecordedChunks.push(event.data);
                }
            };

            myMediaRecorder.onstop = myHandleRecordingStop;

            myMediaRecorder.start();
            myIsRecording = true;

            myRecordButton.innerText = '‚èπÔ∏è Stop Recording';
            myRecordButton.style.backgroundColor = '#007bff';
            myVideoCanvas.style.border = '4px dashed #dc3545';
            myRecordedVideo.style.display = 'none';
            myDownloadLink.style.display = 'none';
            myTrimmingControls.style.display = 'none';
        }

        /**
         * Stops the video recording and processes the final video Blob.
         */
        function myStopRecording() {
            if (myMediaRecorder && myMediaRecorder.state !== 'inactive') {
                myMediaRecorder.stop();
            }
            myIsRecording = false;

            myRecordButton.innerText = 'üî¥ Start Recording';
            myRecordButton.style.backgroundColor = '#dc3545';
            myVideoCanvas.style.border = '2px solid #ccc';
        }

        /**
         * Handler to process the recorded data when the MediaRecorder stops.
         */
        function myHandleRecordingStop() {
            myRecordedVideoBlob = new Blob(myRecordedChunks, { type: myMediaRecorder.mimeType });
            
            const myVideoUrl = URL.createObjectURL(myRecordedVideoBlob);

            myRecordedVideo.src = myVideoUrl;
            myRecordedVideo.style.display = 'block';
            
            // Wait for video metadata to load to get duration
            myRecordedVideo.onloadedmetadata = function() {
                myVideoDuration = myRecordedVideo.duration;
                mySetupTrimmingControls();
            };

            myDownloadLink.style.display = 'none'; // Hide until trimmed
        }

        // --- 7. Video Trimming Functions ---

        /**
         * Sets up the trimming controls with the correct duration
         */
        function mySetupTrimmingControls() {
            myStartSlider.max = myVideoDuration;
            myEndSlider.max = myVideoDuration;
            myStartSlider.value = 0;
            myEndSlider.value = myVideoDuration;
            
            myUpdateTrimmingDisplay();
            myTrimmingControls.style.display = 'block';
            
            // Sync video playback with sliders
            myStartSlider.oninput = function() {
                const startTime = parseFloat(myStartSlider.value);
                const endTime = parseFloat(myEndSlider.value);
                
                if (startTime >= endTime) {
                    myStartSlider.value = endTime - 0.1;
                }
                
                myRecordedVideo.currentTime = parseFloat(myStartSlider.value);
                myUpdateTrimmingDisplay();
            };
            
            myEndSlider.oninput = function() {
                const startTime = parseFloat(myStartSlider.value);
                const endTime = parseFloat(myEndSlider.value);
                
                if (endTime <= startTime) {
                    myEndSlider.value = startTime + 0.1;
                }
                
                myRecordedVideo.currentTime = parseFloat(myEndSlider.value);
                myUpdateTrimmingDisplay();
            };
            
            mySaveTrimmedButton.onclick = myTrimAndSaveVideo;
            myCancelTrimButton.onclick = myCancelTrimming;
        }

        /**
         * Updates the trimming display with current slider values
         */
        function myUpdateTrimmingDisplay() {
            const startTime = parseFloat(myStartSlider.value);
            const endTime = parseFloat(myEndSlider.value);
            const duration = endTime - startTime;
            
            myStartTimeDisplay.textContent = startTime.toFixed(1) + 's';
            myEndTimeDisplay.textContent = endTime.toFixed(1) + 's';
            myDurationDisplay.textContent = duration.toFixed(1) + 's';
        }

        /**
         * Trims the video using FFmpeg-like approach (actually using MediaRecorder on a segment)
         */
        async function myTrimAndSaveVideo() {
            const startTime = parseFloat(myStartSlider.value);
            const endTime = parseFloat(myEndSlider.value);
            
            mySaveTrimmedButton.disabled = true;
            mySaveTrimmedButton.textContent = '‚è≥ Processing...';
            
            try {
                // Create a temporary video element for trimming
                const myTempVideo = document.createElement('video');
                myTempVideo.src = URL.createObjectURL(myRecordedVideoBlob);
                myTempVideo.muted = true;
                
                await new Promise(function(resolve) {
                    myTempVideo.onloadedmetadata = resolve;
                });
                
                // Create a canvas to capture frames
                const myTempCanvas = document.createElement('canvas');
                myTempCanvas.width = myTempVideo.videoWidth;
                myTempCanvas.height = myTempVideo.videoHeight;
                const myTempContext = myTempCanvas.getContext('2d');
                
                // Create a MediaStream from the canvas
                const myCanvasStream = myTempCanvas.captureStream(30); // 30 FPS
                
                // Get audio track from original video
                const myAudioContext = new AudioContext();
                const mySource = myAudioContext.createMediaElementSource(myTempVideo);
                const myDestination = myAudioContext.createMediaStreamDestination();
                mySource.connect(myDestination);
                mySource.connect(myAudioContext.destination);
                
                // Combine video and audio streams
                const myAudioTrack = myDestination.stream.getAudioTracks()[0];
                if (myAudioTrack) {
                    myCanvasStream.addTrack(myAudioTrack);
                }
                
                // Create recorder for trimmed video
                const myTrimmedRecorder = new MediaRecorder(myCanvasStream, { 
                    mimeType: myMediaRecorder.mimeType 
                });
                
                const myTrimmedChunks = [];
                myTrimmedRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        myTrimmedChunks.push(event.data);
                    }
                };
                
                myTrimmedRecorder.onstop = function() {
                    const myTrimmedBlob = new Blob(myTrimmedChunks, { type: myMediaRecorder.mimeType });
                    const myTrimmedUrl = URL.createObjectURL(myTrimmedBlob);
                    
                    myDownloadLink.href = myTrimmedUrl;
                    myDownloadLink.download = 'trimmed_video_' + Date.now() + (myMediaRecorder.mimeType.includes('mp4') ? '.mp4' : '.webm');
                    myDownloadLink.style.display = 'inline';
                    
                    myRecordedVideo.src = myTrimmedUrl;
                    
                    myTrimmingControls.style.display = 'none';
                    mySaveTrimmedButton.disabled = false;
                    mySaveTrimmedButton.textContent = 'üíæ Save Trimmed Video';
                    
                    myAudioContext.close();
                };
                
                // Start recording
                myTrimmedRecorder.start();
                
                // Play and record the trimmed portion
                myTempVideo.currentTime = startTime;
                await myTempVideo.play();
                
                const myDrawInterval = setInterval(function() {
                    if (myTempVideo.currentTime >= endTime || myTempVideo.ended) {
                        clearInterval(myDrawInterval);
                        myTrimmedRecorder.stop();
                        myTempVideo.pause();
                    } else {
                        myTempContext.drawImage(myTempVideo, 0, 0, myTempCanvas.width, myTempCanvas.height);
                    }
                }, 1000 / 30); // 30 FPS
                
            } catch (error) {
                console.error("Error trimming video:", error);
                alert("Error trimming video. Please try again.");
                mySaveTrimmedButton.disabled = false;
                mySaveTrimmedButton.textContent = 'üíæ Save Trimmed Video';
            }
        }

        /**
         * Cancels trimming and shows the full video
         */
        function myCancelTrimming() {
            myTrimmingControls.style.display = 'none';
            
            const myVideoUrl = URL.createObjectURL(myRecordedVideoBlob);
            myDownloadLink.href = myVideoUrl;
            myDownloadLink.download = 'webcam_recording_' + Date.now() + (myMediaRecorder.mimeType.includes('mp4') ? '.mp4' : '.webm');
            myDownloadLink.style.display = 'inline';
        }

        // --- 8. Initialization on Page Load ---

        myLoadResolutionPresets();
        myLoadSupportedFormats();
        myGetCameras();
        
        // Event listeners for camera and resolution changes
        myCameraSelect.onchange = function() {
            myChangeCamera(this.value);
        };
        
        myResolutionSelect.onchange = function() {
            myChangeCamera(myCameraSelect.value);
        };
        
        myPhotoButton.onclick = myTakePhoto;
        myRecordButton.onclick = myToggleRecording;

    </script>
</body>
</html>
