<!DOCTYPE html>
<html>
<head>
    <title>Basic Video Clipper and Saver</title>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/util.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.min.js"></script>
    <style>
        /* Minimal inline CSS */
        body { font-family: sans-serif; text-align: center; max-width: 640px; margin: auto; padding: 20px; }
        h2 { color: #dc3545; }
        .myControlGroup { 
            border: 1px solid #ccc; 
            padding: 15px; 
            border-radius: 5px; 
            margin-bottom: 25px;
        }
        input[type="range"] { width: 100%; margin: 5px 0; }
        .myTimeDisplay { font-weight: bold; margin-bottom: 5px; }
        button { 
            padding: 12px 25px; 
            background-color: #28a745; 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
            font-weight: bold; 
            margin-top: 15px;
        }
        .myStatus { 
            padding: 10px; 
            background-color: #f0f0f0; 
            border-radius: 4px; 
            margin-top: 20px;
        }
        video { border: 2px solid #28a745; max-width: 100%; margin-top: 15px; }
    </style>
</head>
<body>

    <h2>Basic Movie Clipper</h2>
    
    <div class="myStatus" id="myStatusMessage">Initializing...</div>

    <div class="myControlGroup">
        <label for="myFileInput">Select Movie File:</label>
        <input type="file" id="myFileInput" accept="video/*" onchange="myLoadVideo(this.files[0])" />
    </div>

    <video id="myPreviewVideo" controls style="display: none;"></video>

    <div id="myClippingControls" style="display: none;">
        
        <div class="myTimeDisplay" id="myStartTimeDisplay">Start Time: 00:00:00</div>
        <input type="range" id="myStartSlider" min="0" max="1" value="0" step="0.1" oninput="myUpdateClipTime()" />
        
        <div class="myTimeDisplay" id="myEndTimeDisplay">End Time: 00:00:00</div>
        <input type="range" id="myEndSlider" min="0" max="1" value="1" step="0.1" oninput="myUpdateClipTime()" />

        <button onclick="myTrimAndSaveMovie()" id="mySaveButton" disabled>
            ✂️ Clip and Save Movie
        </button>
    </div>
    
    <script>
        // --- 1. Global Variables & FFmpeg Setup (myVariables) ---
        
        // This will hold the instantiated FFmpeg object
        let myFFmpeg = null; 
        
        const myStatusDiv = document.getElementById('myStatusMessage');
        const myPreviewVideo = document.getElementById('myPreviewVideo');
        const myStartSlider = document.getElementById('myStartSlider');
        const myEndSlider = document.getElementById('myEndSlider');
        const myStartTimeDisplay = document.getElementById('myStartTimeDisplay');
        const myEndTimeDisplay = document.getElementById('myEndTimeDisplay');
        const myClippingControls = document.getElementById('myClippingControls');
        const mySaveButton = document.getElementById('mySaveButton');
        const myFileInput = document.getElementById('myFileInput');

        let myIsPlayingClip = false; 

        // Define the base URL for the core files (must match the version)
        const myCoreBaseURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.15/dist/umd';


        // --- 2. Utility Functions ---
        
        /**
         * Converts a time in seconds to an HH:MM:SS.X string for user display.
         * @param {number} myTotalSeconds The time in seconds.
         * @returns {string} The formatted time string.
         */
        function myFormatTime(myTotalSeconds) {
            const myHours = Math.floor(myTotalSeconds / 3600).toString().padStart(2, '0');
            const myMinutes = Math.floor((myTotalSeconds % 3600) / 60).toString().padStart(2, '0');
            const mySeconds = (myTotalSeconds % 60).toFixed(1).toString().padStart(4, '0');
            return `${myHours}:${myMinutes}:${mySeconds}`;
        }
        
        /**
         * Converts a user-selected File object into a buffer array FFmpeg can use.
         * @param {File} myFile The file object to read.
         * @returns {Promise<Uint8Array>} The file data as a Uint8Array.
         */
        async function myGetFileBuffer(myFile) {
            const myFileArrayBuffer = await myFile.arrayBuffer();
            return new Uint8Array(myFileArrayBuffer);
        }

        // --- 3. Core Video Loading & UI Setup ---

        /**
         * Loads the selected video file and sets up clipping controls.
         * Uses async/await as preferred.
         * @param {File} myFile The selected video file object.
         */
        async function myLoadVideo(myFile) {
            if (!myFile) {
                myClippingControls.style.display = 'none';
                myPreviewVideo.style.display = 'none';
                return;
            }
            
            if (!myFFmpeg) {
                myStatusDiv.innerText = 'FFmpeg is still initializing. Please wait a moment.';
                return;
            }

            // Create a temporary URL for the video file
            myPreviewVideo.src = URL.createObjectURL(myFile);
            myPreviewVideo.style.display = 'block';
            myClippingControls.style.display = 'none';
            mySaveButton.disabled = true;

            myStatusDiv.innerText = 'Loading video metadata...';
            
            // Wait for the video metadata (like duration) to load
            await new Promise(resolve => {
                myPreviewVideo.onloadedmetadata = () => {
                    resolve();
                };
            });
            
            mySetSliders(myPreviewVideo.duration);
            myClippingControls.style.display = 'block';
            mySaveButton.disabled = false;

            // Attach the event listener for continuous clipping loop preview
            myPreviewVideo.ontimeupdate = myCheckClipEnd;
            
            myStatusDiv.innerText = 'Video loaded. Adjust the sliders to set clip points.';
        }

        /**
         * Sets the max value of the sliders based on the video's duration.
         * @param {number} myDuration The total video duration in seconds.
         */
        function mySetSliders(myDuration) {
            // Sliders max value should be the duration, step is 0.1s for fine control
            myStartSlider.max = myDuration;
            myEndSlider.max = myDuration;
            
            // Default start is 0, default end is the max duration
            myStartSlider.value = 0;
            myEndSlider.value = myDuration;

            myUpdateClipTime(); // Update the display text initially
        }

        // --- 4. Clipping Logic (User-Sensible Sliders) ---

        /**
         * Called when a slider value changes. Updates display and enforces constraints.
         */
        function myUpdateClipTime() {
            let myStartTime = parseFloat(myStartSlider.value);
            let myEndTime = parseFloat(myEndSlider.value);
            
            // Constraint Check: Ensure Start Time is not greater than End Time
            if (myStartTime >= myEndTime) {
                // Adjust the opposing slider slightly to maintain validity
                if (document.activeElement === myStartSlider) {
                    myEndTime = Math.min(myStartTime + 0.1, myPreviewVideo.duration);
                    myEndSlider.value = myEndTime;
                } else {
                    myStartTime = Math.max(myEndTime - 0.1, 0);
                    myStartSlider.value = myStartTime;
                }
            }
            
            // Update the user-friendly time displays
            myStartTimeDisplay.textContent = `Start Time: ${myFormatTime(myStartTime)}`;
            myEndTimeDisplay.textContent = `End Time: ${myFormatTime(myEndTime)}`;

            // Seek the video to the start time for preview when dragging
            myPreviewVideo.currentTime = myStartTime;
        }

        /**
         * Checks the video's current time against the end clip point for looping (for preview).
         */
        function myCheckClipEnd() {
            const myEndTime = parseFloat(myEndSlider.value);

            // If the current time is at or past the end point, loop back to the start
            if (myPreviewVideo.currentTime >= myEndTime) {
                myPreviewVideo.currentTime = parseFloat(myStartSlider.value);
                // Keep playing to loop the preview
                if (myPreviewVideo.paused) {
                    myPreviewVideo.play();
                }
            }
        }

        // --- 5. FFmpeg Trimming and Saving Logic ---

        /**
         * Executes the FFmpeg trim command and saves the resulting file.
         * Uses async/await as preferred.
         */
        async function myTrimAndSaveMovie() {
            mySaveButton.disabled = true;
            const myInputFile = myFileInput.files[0];
            const myOutputFileName = 'clipped_movie_' + Date.now() + '.mp4';
            const myInputFileName = 'input.mp4';
            
            if (!myFFmpeg || !myFFmpeg.loaded) {
                myStatusDiv.innerText = 'Error: FFmpeg is not loaded correctly.';
                mySaveButton.disabled = false;
                return;
            }

            const myStartTime = parseFloat(myStartSlider.value);
            const myEndTime = parseFloat(myEndSlider.value);
            const myDuration = myEndTime - myStartTime;

            // 1. Write File to Virtual FS
            myStatusDiv.innerText = 'Writing movie to virtual file system...';
            try {
                myFFmpeg.FS('writeFile', myInputFileName, await myGetFileBuffer(myInputFile));
            } catch (error) {
                myStatusDiv.innerText = `Error writing file to FS: ${error.message}`;
                mySaveButton.disabled = false; return;
            }

            // 2. Run the FFmpeg trim command
            myStatusDiv.innerText = 'Trimming movie... (This may take a moment)';
            try {
                // FFmpeg command: -ss start time, -i input file, -t duration, -c copy (fastest)
                await myFFmpeg.run(
                    '-ss', myStartTime.toString(),
                    '-i', myInputFileName,
                    '-t', myDuration.toString(),
                    '-c', 'copy',
                    myOutputFileName
                );
            } catch (error) {
                myStatusDiv.innerText = `Error trimming movie: ${error.message}`;
                console.error(error);
                mySaveButton.disabled = false; return;
            }

            // 3. Read Output and Download
            myStatusDiv.innerText = 'Trimming complete. Preparing download...';
            try {
                const myClippedData = myFFmpeg.FS('readFile', myOutputFileName);
                const myMovieBlob = new Blob([myClippedData.buffer], { type: 'video/mp4' });
                const myDownloadUrl = URL.createObjectURL(myMovieBlob);

                // Create and click a temporary link for download
                const myDownloadLink = document.createElement('a');
                myDownloadLink.href = myDownloadUrl;
                myDownloadLink.download = myOutputFileName;
                document.body.appendChild(myDownloadLink);
                myDownloadLink.click();
                document.body.removeChild(myDownloadLink);

                myStatusDiv.innerText = 'Success! Your clipped movie has been downloaded.';
            } catch (error) {
                myStatusDiv.innerText = `Error during download: ${error.message}`;
                mySaveButton.disabled = false; return;
            }

            // 4. Cleanup
            try {
                 myFFmpeg.FS('unlink', myInputFileName);
                 myFFmpeg.FS('unlink', myOutputFileName);
            } catch (e) { /* Ignore cleanup errors */ }
            
            mySaveButton.disabled = true; // Disable button until a new file is loaded
        }
        
        // --- 6. Initialization (The Fix) ---
        // We ensure FFmpeg is available before attempting to use it.
        (async () => {
             myStatusDiv.innerText = 'Initializing FFmpeg library in the background...';
             
             try {
                // Wait for the scripts to load, then use the globally defined constructors (FFmpeg and FFmpegUtil)
                // We wrap the instantiation in an async function to use the await keywords correctly
                const FFmpegClass = window.FFmpeg;
                if (!FFmpegClass) throw new Error("FFmpeg class not found after script load.");

                myFFmpeg = new FFmpegClass(); 
                
                await myFFmpeg.load({
                    myCoreURL: await FFmpegUtil.toBlobURL(`${myCoreBaseURL}/ffmpeg-core.js`, 'text/javascript'),
                    myWasmURL: await FFmpegUtil.toBlobURL(`${myCoreBaseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                });
                myStatusDiv.innerText = 'Ready. Select a movie file.';
             } catch (error) {
                myStatusDiv.innerText = 'Error initializing FFmpeg. Please ensure scripts are loaded and check the console.';
                console.error("FFmpeg Initialization Error:", error);
                mySaveButton.disabled = true;
             }
        })();
    </script>

</body>
</html>
